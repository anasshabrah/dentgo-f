--- C:\Users\hanos\cb\frontend\src\modules\payments\api.ts ---
export * from "../../api/cards";
export * from "../../api/payments";
export { createSubscription } from "../../api/subscriptions";


--- C:\Users\hanos\cb\frontend\src\modules\payments\paymentsClient.ts ---
// src/modules/payments/paymentsClient.ts
import { API_BASE } from '@/config';
import { fetchCards as apiFetchCards, createCard as apiCreateCard } from '@/api/cards';
import type { CardData } from './types';
import axios from 'axios';

// Cards
export async function fetchCards(): Promise<CardData[]> {
  return apiFetchCards();
}

export async function addCard(payload: {
  paymentMethodId: string;
  nickName: string | null;
}): Promise<void> {
  return apiCreateCard(payload);
}

// Stripe Customer & Intents
export async function createCustomer(): Promise<string> {
  const resp = await axios.post(
    `${API_BASE}/api/payments/create-customer`,
    {},
    { withCredentials: true, headers: { 'Content-Type': 'application/json' } }
  );
  return resp.data.customerId;
}

export async function createSetupIntent(): Promise<string> {
  const resp = await fetch(
    `${API_BASE}/api/payments/create-setup-intent`,
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
    }
  );
  if (!resp.ok) {
    const err = await resp.json().catch(() => ({}));
    throw new Error(err.error || 'Failed to create SetupIntent.');
  }
  const { clientSecret } = (await resp.json()) as { clientSecret: string };
  return clientSecret;
}

export async function createPaymentIntent(amount: number): Promise<string> {
  const resp = await fetch(
    `${API_BASE}/api/payments/create-payment-intent`,
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ amount }),
    }
  );
  if (!resp.ok) {
    const err = await resp.json().catch(() => ({}));
    throw new Error(err.error || 'Failed to create PaymentIntent.');
  }
  const { clientSecret } = (await resp.json()) as { clientSecret: string };
  return clientSecret;
}

export async function createSubscriptionIntent(
  priceId: string,
  paymentMethodId: string
): Promise<{ clientSecret: string; subscriptionId: string; status: string }> {
  const resp = await fetch(
    `${API_BASE}/api/payments/create-subscription`,
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ priceId, paymentMethodId }),
    }
  );
  if (!resp.ok) {
    const err = await resp.json().catch(() => ({}));
    throw new Error(err.error || 'Failed to create subscription intent.');
  }
  return (await resp.json()) as { clientSecret: string; subscriptionId: string; status: string };
}

// Active Subscription
export async function fetchActiveSubscription(): Promise<{
  subscriptionId: string;
  status: string;
  currentPeriodEnd: number;
}> {
  const resp = await axios.get(
    `${API_BASE}/api/subscriptions`,
    { withCredentials: true }
  );
  return resp.data;
}

// Customer Portal Session
export async function createPortalSession(
  args?: { return_url: string }
): Promise<{ url: string }> {
  // If return_url provided, include in request body
  const body = args ? JSON.stringify({ return_url: args.return_url }) : undefined;

  const resp = await fetch(
    `${API_BASE}/api/payments/create-portal-session`,
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body,
    }
  );
  if (!resp.ok) {
    const err = await resp.json().catch(() => ({}));
    throw new Error(err.error || 'Failed to create portal session.');
  }
  return (await resp.json()) as { url: string };
}


--- C:\Users\hanos\cb\frontend\src\modules\payments\routes.tsx ---
// src/modules/payments/routes.tsx
import React, { lazy, Suspense } from 'react';
import { Navigate } from 'react-router-dom';

const Wallet = lazy(() => import('./Wallet'));
const SubscribeWizard = lazy(() => import('./SubscribeWizard'));

const withSuspense = (Component: React.LazyExoticComponent<React.ComponentType<any>>) => (
  <Suspense fallback={<div>Loading...</div>}>
    <Component />
  </Suspense>
);

const paymentRoutes = [
  {
    path: 'wallet',
    element: withSuspense(Wallet),
  },
  {
    path: 'subscribe',
    element: withSuspense(SubscribeWizard),
  },
  // Redirects from legacy paths
  { path: 'payment-method', element: <Navigate to="wallet" replace /> },
  { path: 'bank-cards', element: <Navigate to="wallet" replace /> },
  { path: 'add-new-card', element: <Navigate to="wallet" replace /> },
];

export default paymentRoutes;


--- C:\Users\hanos\cb\frontend\src\modules\payments\types.ts ---
// src/modules/payments/types.ts
export interface CardData {
  id: string;
  last4: string;
  network: string;
  paymentMethodId: string;
  isActive: boolean;
}


--- C:\Users\hanos\cb\frontend\src\modules\payments\Wallet.tsx ---
// src/modules/payments/Wallet.tsx
import React, { useState, useEffect } from 'react';
import { useStripeData } from '@/context/StripeContext';
import { CardRow } from '@/modules/payments/components/CardRow';
import { PaymentMethodSelector } from '@/modules/payments/components/PaymentMethodSelector';
import { PlanCard } from '@/modules/payments/components/PlanCard';
import StripeElements from '@/lib/stripeClient';
import { createSetupIntent } from '@/modules/payments/paymentsClient';
import { useToast } from '@components/ui/ToastProvider';

const tabs = ['Saved Cards', 'Add Card', 'Plan & Billing'] as const;
type Tab = typeof tabs[number];

const Wallet: React.FC = () => {
  const [active, setActive] = useState<Tab>('Saved Cards');
  const { cards, isLoadingCards } = useStripeData();
  const { addToast } = useToast();

  const [clientSecret, setClientSecret] = useState<string | null>(null);
  const [loadingSecret, setLoadingSecret] = useState(false);

  // Whenever user switches to "Add Card", fetch the SetupIntent
  useEffect(() => {
    if (active === 'Add Card') {
      setLoadingSecret(true);
      createSetupIntent()
        .then(secret => setClientSecret(secret))
        .catch(err => addToast(err.message || 'Failed to initialize payment form', 'error'))
        .finally(() => setLoadingSecret(false));
    }
  }, [active, addToast]);

  const handleCardAdded = () => {
    addToast('Card linked successfully', 'success');
    setActive('Saved Cards');
  };

  const handleCardError = (err: any) => {
    addToast(err.message || 'Failed to add card', 'error');
  };

  return (
    <div className="max-w-lg mx-auto my-8 p-4">
      {/* Tabs */}
      <div className="flex border-b mb-4">
        {tabs.map(tab => (
          <button
            key={tab}
            onClick={() => setActive(tab)}
            className={`flex-1 py-2 text-center focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-background
              ${
                active === tab
                  ? 'border-b-2 border-primary font-semibold text-primary'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
          >
            {tab}
          </button>
        ))}
      </div>

      {/* Saved Cards */}
      {active === 'Saved Cards' && (
        <div className="bg-gray-50 dark:bg-gray-900 rounded">
          {isLoadingCards ? (
            Array.from({ length: 3 }).map((_, i) => (
              <div
                key={i}
                className="h-16 bg-gray-200 dark:bg-gray-700 animate-pulse mb-2 rounded"
              />
            ))
          ) : cards && cards.length > 0 ? (
            cards.map(c => <CardRow key={c.id} card={c} />)
          ) : (
            <div className="p-4 text-gray-500 dark:text-gray-400">
              No saved cards.
            </div>
          )}
        </div>
      )}

      {/* Add Card */}
      {active === 'Add Card' && (
        <div className="bg-gray-50 dark:bg-gray-900 rounded p-4">
          {loadingSecret ? (
            <div className="text-center text-gray-500">Loading payment formâ€¦</div>
          ) : clientSecret ? (
            <StripeElements options={{ clientSecret }}>
              <PaymentMethodSelector
                onSuccess={handleCardAdded}
                onError={handleCardError}
              />
            </StripeElements>
          ) : null}
        </div>
      )}

      {/* Plan & Billing */}
      {active === 'Plan & Billing' && (
        <div className="bg-gray-50 dark:bg-gray-900 rounded p-4">
          <PlanCard />
        </div>
      )}
    </div>
  );
};

export default Wallet;


--- C:\Users\hanos\cb\frontend\src\modules\payments\components\CardRow.tsx ---
// src/modules/payments/components/CardRow.tsx
import React from 'react';
import type { CardData } from '@/modules/payments/types';
import visaLogo from '@/assets/cards/visa.svg';
import mcLogo from '@/assets/cards/mastercard.svg';
import amexLogo from '@/assets/cards/amex.svg';
import cardIcon from '@/assets/cards/card.svg';

const logos: Record<string, string> = {
  visa: visaLogo,
  mastercard: mcLogo,
  amex: amexLogo,
};

export const CardRow: React.FC<{ card: CardData }> = ({ card }) => {
  const key = card.network?.toLowerCase() || '';
  const logoSrc = logos[key] || cardIcon;

  return (
    <div className="flex items-center justify-between p-4 border-b bg-white dark:bg-gray-800">
      <div className="flex items-center gap-4">
        <div className="w-12 h-8 flex items-center justify-center bg-gray-100 dark:bg-gray-700 rounded">
          <img src={logoSrc} alt={card.network || 'Card'} className="w-8 h-8 object-contain" />
        </div>
        <div>
          <div className="font-semibold text-gray-900 dark:text-gray-100">
            **** {card.last4}
          </div>
          <span
            className={`inline-block px-2 py-0.5 text-xs font-semibold rounded-full ${
              card.isActive
                ? 'bg-green-100 text-green-800 dark:bg-green-200 dark:text-green-900'
                : 'bg-red-100 text-red-800 dark:bg-red-200 dark:text-red-900'
            }`}
          >
            {card.isActive ? 'Active' : 'Inactive'}
          </span>
        </div>
      </div>
    </div>
  );
};


--- C:\Users\hanos\cb\frontend\src\modules\payments\components\PaymentMethodSelector.tsx ---
// src/modules/payments/components/PaymentMethodSelector.tsx
import React, { useState } from 'react';
import { PaymentElement, useStripe, useElements } from '@stripe/react-stripe-js';
import { useStripeData } from '@/context/StripeContext';
import { LockClosedIcon } from '@heroicons/react/24/solid';
import { useToast } from '@components/ui/ToastProvider';

interface PaymentMethodSelectorProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export const PaymentMethodSelector: React.FC<PaymentMethodSelectorProps> = ({
  onSuccess,
  onError,
}) => {
  const { addToast } = useToast();
  const stripe = useStripe();
  const elements = useElements();
  const { addCard } = useStripeData();
  const [nickname, setNickname] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!stripe || !elements) {
      const error = new Error('Payment form not ready. Please try again.');
      addToast(error.message, 'error');
      onError?.(error);
      return;
    }

    setLoading(true);

    try {
      const result = (await stripe.confirmSetup({
        elements,
        confirmParams: { return_url: window.location.href },
      })) as any;

      if (result.error) throw result.error;

      const pm = result.setupIntent?.payment_method as string;
      await addCard(pm, nickname || null);
      setNickname('');
      addToast('Card added successfully!', 'success');
      onSuccess?.();
    } catch (err: any) {
      const error = new Error(err?.message || 'Failed to add card. Please try again.');
      addToast(error.message, 'error');
      onError?.(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4 p-4 bg-white dark:bg-gray-800 rounded">
      {/* ... */}
    </form>
  );
};


--- C:\Users\hanos\cb\frontend\src\modules\payments\components\PlanCard.tsx ---
// src/modules/payments/components/PlanCard.tsx
import React from 'react';
import { useStripeData } from '@/context/StripeContext';
import { FREE_MESSAGES_PER_DAY } from '@/config';

export const PlanCard: React.FC = () => {
  const { subscription, openCustomerPortal } = useStripeData();

  // Handle loading state
  if (subscription === undefined) {
    return (
      <div className="p-4 bg-white dark:bg-gray-800 rounded animate-pulse">
        <div className="h-6 bg-gray-200 dark:bg-gray-700 rounded mb-2" />
        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-4" />
      </div>
    );
  }

  // If no subscription record, treat as Basic free plan
  if (Array.isArray(subscription) && subscription.length === 0) {
    return (
      <div className="p-4 bg-white dark:bg-gray-800 rounded space-y-4 text-center">
        <h3 className="text-lg font-semibold">Basic Plan</h3>
        <p className="text-gray-600">Free, {FREE_MESSAGES_PER_DAY} message{FREE_MESSAGES_PER_DAY > 1 ? 's' : ''}/day</p>
        <button
          onClick={async () => {
            const url = await openCustomerPortal();
            window.location.href = url;
          }}
          className="w-full py-2 bg-primary text-white rounded hover:bg-primary/90 transition"
        >
          Upgrade to Plus
        </button>
      </div>
    );
  }

  // If subscription exists
  const sub = Array.isArray(subscription) ? subscription[0] : subscription;

  if (!sub || sub.status !== 'ACTIVE') {
    return (
      <div className="p-4 bg-white dark:bg-gray-800 rounded text-center text-gray-500">
        No active paid subscription.
      </div>
    );
  }

  const renewDate = sub.currentPeriodEnd
    ? new Date(sub.currentPeriodEnd * 1000).toLocaleDateString()
    : 'â€”';

  return (
    <div className="p-4 bg-white dark:bg-gray-800 rounded space-y-4">
      <div className="flex items-center justify-between">
        <span className="inline-block px-3 py-1 text-sm font-semibold bg-blue-100 text-blue-800 dark:bg-blue-200 dark:text-blue-900 rounded-full">
          Active Plus
        </span>
        <span className="text-sm text-gray-600 dark:text-gray-400">
          Renews: {renewDate}
        </span>
      </div>
      <button
        onClick={async () => {
          const url = await openCustomerPortal();
          window.location.href = url;
        }}
        className="w-full py-2 bg-primary text-white rounded hover:bg-primary/90 transition"
      >
        Manage in Stripe Portal
      </button>
    </div>
  );
};

--- C:\Users\hanos\cb\frontend\src\modules\payments\SubscribeWizard\index.tsx ---
// src/modules/payments/SubscribeWizard/index.tsx
import React, { useState } from 'react';
import { StepChoosePlan } from './StepChoosePlan';
import { StepPayment } from './StepPayment';
import StepReview from './StepReview';
import StepSuccess from './StepSuccess';

const steps = ['choose', 'payment', 'review', 'success'] as const;
type Step = typeof steps[number];

const SubscribeWizard: React.FC = () => {
  const [current, setCurrent] = useState<Step>('choose');
  const [planId, setPlanId] = useState<string>('plus');

  return (
    <div className="max-w-md mx-auto my-8 bg-white dark:bg-gray-800 rounded shadow">
      {current === 'choose' && (
        <StepChoosePlan
          onNext={p => {
            setPlanId(p);
            // Always go to review step first
            setCurrent('review');
          }}
        />
      )}

      {current === 'payment' && (
        <StepPayment
          planId={planId}
          onNext={() => setCurrent('review')}
        />
      )}

      {current === 'review' && (
        <StepReview
          planId={planId}
          onBack={() => {
            // If free plan, back goes to chooser; otherwise back to payment
            setCurrent(planId === 'basic' ? 'choose' : 'payment');
          }}
          onSuccess={() => setCurrent('success')}
        />
      )}

      {current === 'success' && (
        <StepSuccess planId={planId} />
      )}
    </div>
  );
};

export default SubscribeWizard;


--- C:\Users\hanos\cb\frontend\src\modules\payments\SubscribeWizard\StepChoosePlan.tsx ---
// src/modules/payments/SubscribeWizard/StepChoosePlan.tsx

import React, { useMemo } from 'react';
import { FREE_MESSAGES_PER_DAY } from '@/config';

export const StepChoosePlan: React.FC<{ onNext: (planId: string) => void }> = ({
  onNext,
}) => {
  const [selected, setSelected] = React.useState<string>('plus');

  // Ensure it's always treated as a number and memoized
  const freeCount = useMemo(() => FREE_MESSAGES_PER_DAY, []);

  const plans = useMemo(
    () => [
      {
        id: 'basic',
        name: 'Basic',
        price: 0,
        description: `Free, ${freeCount} message${
          freeCount > 1 ? 's' : ''
        }/day`,
      },
      {
        id: 'plus',
        name: 'Plus',
        price: 2500,
        description: '$25/month, unlimited',
      },
    ],
    [freeCount]
  );

  return (
    <div className="space-y-6 p-4">
      <h2 className="text-xl font-semibold">Choose a plan</h2>
      <div className="grid gap-4">
        {plans.map((p) => (
          <button
            key={p.id}
            type="button"
            onClick={() => setSelected(p.id)}
            className={`p-4 border rounded ${
              selected === p.id ? 'border-primary bg-primary/10' : 'border-gray-300'
            }`}
          >
            <div className="flex justify-between">
              <span className="font-medium">{p.name}</span>
              <span className="font-semibold">
                {p.price === 0
                  ? 'Free'
                  : `$${(p.price / 100).toFixed(2)}/mo`}
              </span>
            </div>
            <p className="text-sm text-gray-600">{p.description}</p>
          </button>
        ))}
      </div>
      <button
        onClick={() => onNext(selected)}
        className="mt-4 w-full py-2 bg-primary text-white rounded hover:bg-primary/90"
      >
        Next
      </button>
    </div>
  );
};


--- C:\Users\hanos\cb\frontend\src\modules\payments\SubscribeWizard\StepPayment.tsx ---
// src/modules/payments/SubscribeWizard/StepPayment.tsx
import React, { useEffect, useState } from 'react';
import { PaymentMethodSelector } from '@/modules/payments/components/PaymentMethodSelector';
import { createSetupIntent } from '@/modules/payments/paymentsClient';
import StripeElements from '@/lib/stripeClient';
import { useToast } from '@components/ui/ToastProvider';

export interface StepPaymentProps {
  planId: string;
  onNext: () => void;
}

export const StepPayment: React.FC<StepPaymentProps> = ({ planId, onNext }) => {
  const { addToast } = useToast();
  const planName = planId === 'plus' ? 'Plus' : 'Basic';
  const [clientSecret, setClientSecret] = useState<string | null>(null);

  // If user chose the free plan, skip payment immediately
  useEffect(() => {
    if (planId === 'basic') {
      addToast('Free plan selected. No payment required.', 'success');
      onNext();
    }
  }, [planId, onNext, addToast]);

  // Only initialize Stripe for paid plan
  useEffect(() => {
    if (planId === 'plus') {
      const init = async () => {
        try {
          const secret = await createSetupIntent();
          setClientSecret(secret);
        } catch (err: any) {
          addToast(
            err instanceof Error
              ? err.message
              : 'Failed to initialize payment form.',
            'error'
          );
        }
      };
      init();
    }
  }, [planId, addToast]);

  // While loading clientSecret for plus plan, show loader
  if (planId === 'plus' && !clientSecret) {
    return (
      <div className="p-4 bg-white dark:bg-gray-800 rounded">
        <p className="text-gray-500 dark:text-gray-400">
          Loading payment form...
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6 p-4">
      <h2 className="text-xl font-semibold">Enter payment for {planName} plan</h2>
      {planId === 'plus' && clientSecret && (
        <StripeElements options={{ clientSecret }}>
          <PaymentMethodSelector
            onSuccess={() => {
              addToast('Payment method added successfully!', 'success');
              onNext();
            }}
          />
        </StripeElements>
      )}
    </div>
  );
};


--- C:\Users\hanos\cb\frontend\src\modules\payments\SubscribeWizard\StepReview.tsx ---
// src/modules/payments/SubscribeWizard/StepReview.tsx
import React, { useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import { Elements, useStripe } from '@stripe/react-stripe-js';
import { useStripeData } from '@/context/StripeContext';
import { useToast } from '@components/ui/ToastProvider';
import { STRIPE_PK } from '@/config';

export interface StepReviewProps {
  planId: string;
  onSuccess: () => void;
  onBack: () => void;
  onAddCard: () => void;
}

const PLAN_TO_PRICE: Record<string, string | null> = {
  basic: null,
  plus: 'price_1RGpe2GaZTzD8EjfQ1nZydXJ',
};

const InnerReview: React.FC<StepReviewProps> = ({
  planId,
  onSuccess,
  onBack,
  onAddCard,
}) => {
  const toast = useToast();
  const stripe = useStripe();
  const { cards, subscribe } = useStripeData();
  const [loading, setLoading] = useState(false);

  const planName = planId === 'plus' ? 'Plus' : 'Basic';
  const priceLabel = planId === 'plus' ? '$25.00' : 'Free';
  const priceId = PLAN_TO_PRICE[planId];

  const card = cards && cards.length > 0 ? cards[0] : null;
  const paymentMethodId = card?.paymentMethodId;

  const handleConfirm = async () => {
    // Free plan: finish immediately
    if (!priceId) {
      toast.addToast('Free plan selected. No payment required.', 'success');
      onSuccess();
      return;
    }

    // No Stripe loaded?
    if (!stripe) {
      toast.addToast('Stripe has not loaded yet. Please try again.', 'error');
      return;
    }

    // No card? redirect to add-card flow
    if (!paymentMethodId) {
      toast.addToast('Letâ€™s add your first card!', 'info');
      onAddCard();
      return;
    }

    setLoading(true);
    try {
      const { clientSecret, status } = await subscribe(priceId, paymentMethodId);
      if (status === 'requires_action' && clientSecret) {
        const result = await stripe.confirmPayment({
          clientSecret,
          confirmParams: { return_url: window.location.href },
        });
        if (result.error) throw result.error;
      }
      toast.addToast('Subscription completed successfully!', 'success');
      onSuccess();
    } catch (err: any) {
      toast.addToast(err.message || 'Subscription failed. Please try again.', 'error');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="p-4 space-y-6">
      <h2 className="text-xl font-semibold">Review your subscription</h2>

      <div className="space-y-2">
        <div>
          <span className="font-medium">Plan:</span> {planName}
        </div>
        <div>
          <span className="font-medium">Price:</span> {priceLabel}/month
        </div>
        <div>
          <span className="font-medium">Payment Method:</span><br />
          {card
            ? <>**** {card.last4} ({card.network})</>
            : <em>No card found</em>
          }
        </div>
      </div>

      <div className="flex gap-4">
        <button
          type="button"
          onClick={onBack}
          className="flex-1 py-2 border rounded hover:bg-gray-100 transition"
        >
          Back
        </button>
        <button
          onClick={handleConfirm}
          disabled={loading}
          className={`flex-1 py-2 bg-primary text-white rounded transition ${
            loading ? 'opacity-50 cursor-not-allowed' : 'hover:bg-primary/90'
          }`}
        >
          {loading ? 'Processingâ€¦' : 'Confirm & Subscribe'}
        </button>
      </div>
    </div>
  );
};

export default function StepReview(props: StepReviewProps) {
  const stripePromise = loadStripe(STRIPE_PK);
  return (
    <Elements stripe={stripePromise}>
      <InnerReview {...props} />
    </Elements>
  );
}


--- C:\Users\hanos\cb\frontend\src\modules\payments\SubscribeWizard\StepSuccess.tsx ---
// src/modules/payments/SubscribeWizard/StepSuccess.tsx
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import { FREE_MESSAGES_PER_DAY } from '@/config';

export interface StepSuccessProps {
  planId: string;
}

const StepSuccess: React.FC<StepSuccessProps> = ({ planId }) => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  useEffect(() => {
    // Refresh cards & subscription data
    queryClient.invalidateQueries(['cards']);
    queryClient.invalidateQueries(['subscription']);
  }, [queryClient]);

  const isFree = planId === 'basic';
  const title = isFree
    ? 'Free Plan Activated!'
    : 'Subscription Successful!';
  const message = isFree
    ? `You're on the Basic plan with ${FREE_MESSAGES_PER_DAY} free message${FREE_MESSAGES_PER_DAY > 1 ? 's' : ''} per day. Enjoy your Dentgo experience!`
    : 'Thank you for subscribing. You now have unlimited access.';

  const handleStart = () => {
    navigate('/dentgo-chat');
  };

  return (
    <div className="p-4 text-center space-y-4">
      <h2 className="text-2xl font-semibold">{title}</h2>
      <p className="text-gray-600">{message}</p>
      <button
        onClick={handleStart}
        className="mt-4 px-6 py-3 bg-primary text-white text-lg font-semibold rounded shadow hover:bg-primary/90 transition"
      >
        Start Now
      </button>
    </div>
  );
};

export default StepSuccess;


